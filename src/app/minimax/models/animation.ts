import { Node } from './tree';

// Specifies which piece of data on a node should be hidden
export const enum DataHiddenForUserGuess {
  None,
  Alpha,
  Beta,
  Val,
}

// An animation frame for a tree, including SVG display data
export type SVGTreeAnimationFrame = {
  tree: SVGTree;
  currNodeId: string | null;
  optimalPathIds: string[];
  commentary: string;
};

// All the data for a tree, including SVG display data
export type SVGTree = {
  nodes: SVGNode[];
  edges: SVGEdge[];
};

// The SVG data for edges displayed on the screen
export type SVGEdge = {
  startX: number;
  startY: number;
  endX: number;
  endY: number;
};

// The SVG data for nodes displayed on the screen as well as the actual node data
export type SVGNode = {
  centerX: number;
  centerY: number;
  internalNode: Node;
  dataHiddenForUserGuess: DataHiddenForUserGuess;
};

// An animation frame excluding SVG data, generated by the algorithm for separation of concerns
export type TreeAnimationFrame = {
  rootNode: Node;
  currNodeId: string | null;
  optimalPathIds: string[];
  commentary: string;
};

// Height of SVG canvas in pixels
export const SVG_HEIGHT = 265;

// Width of SVG canvas in pixels
export const SVG_WIDTH = 1150;

// Radius of a node displayed on the SVG canvas in pixels
export const SVG_NODE_RADIUS = 5;

// The x distance in pixels between the root node and its children when displayed on the screen
const SVG_INITIAL_X_STEP = 280;

// The y distance between any node and its children when displayed on the screen
const SVG_Y_STEP = 60;

// Convert a TreeAnimationFrame -> SVGTreeAnimationFrame
export function treeAnimationFrameToSVGAnimationframe({
  rootNode,
  currNodeId,
  optimalPathIds,
  commentary,
}: TreeAnimationFrame): SVGTreeAnimationFrame {
  return {
    tree: treeToTreeSVG(rootNode, SVG_WIDTH, SVG_INITIAL_X_STEP, SVG_Y_STEP),
    currNodeId,
    optimalPathIds,
    commentary,
  };
}

// Convert the internal data representation of a tree generated by the algorithm to an SVG representation for display
export function treeToTreeSVG(
  rootNode: Node,
  width: number,
  xStep: number,
  yStep: number
): SVGTree {
  const treeSVG = {
    edges: [],
    nodes: [],
  };

  genTreeSVGFromTreeRecurse(
    rootNode,
    width / 2,
    yStep / 5,
    xStep,
    yStep,
    treeSVG
  );

  return treeSVG;
}

// Wrapper to generate TreeAnimationFrame objects
export function genTreeAnimationFrame(
  rootNode: Node,
  currNodeId: string | null,
  commentary: string
): TreeAnimationFrame {
  return {
    rootNode,
    currNodeId,
    optimalPathIds: genNodeIdListFromOptimalPath(rootNode),
    commentary,
  };
}

// Convert the tree's optimal path into a list of node ids for displaying the optimal path
function genNodeIdListFromOptimalPath(rootNode: Node): string[] {
  const ids = [rootNode.id];

  let currNode = rootNode;

  while (currNode.chosenChild !== null) {
    currNode = currNode.chosenChild;
    ids.push(currNode.id);
  }

  return ids;
}

// Generate an SVG representation of a tree recursively
function genTreeSVGFromTreeRecurse(
  node: Node,
  xPos: number,
  yPos: number,
  xStep: number,
  yStep: number,
  treeSVG: SVGTree
): void {
  if (node.leftChild !== null) {
    treeSVG.edges.push({
      startX: xPos,
      startY: yPos,
      endX: xPos - xStep,
      endY: yPos + yStep,
    });

    genTreeSVGFromTreeRecurse(
      node.leftChild,
      xPos - xStep,
      yPos + yStep,
      xStep / 2,
      yStep,
      treeSVG
    );
  }

  if (node.rightChild !== null) {
    treeSVG.edges.push({
      startX: xPos,
      startY: yPos,
      endX: xPos + xStep,
      endY: yPos + yStep,
    });

    genTreeSVGFromTreeRecurse(
      node.rightChild,
      xPos + xStep,
      yPos + yStep,
      xStep / 2,
      yStep,
      treeSVG
    );
  }

  treeSVG.nodes.push({
    centerX: xPos,
    centerY: yPos,
    internalNode: node,
    dataHiddenForUserGuess: DataHiddenForUserGuess.None,
  });
}
